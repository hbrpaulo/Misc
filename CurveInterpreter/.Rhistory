try(silent = TRUE,
print(ts.plot(w3[,i]))
)
try(silent = TRUE,
print(ts.plot(na.omit(w3[,i])))
)
for(i in 1:ncol(w3)){
try(silent = TRUE,
print(ts.plot(na.omit(w3[,i])))
)
}
par(mfrow = c(3,3))
par(mfrow = c(3,3))
for(i in 1:ncol(w3)){
try(silent = TRUE,
print(ts.plot(na.omit(w3[,i])))
)
}
for(i in 1:ncol(w3)){
try(silent = TRUE,
print(
ts.plot(na.omit(w3[,i]), main = colnames(w3)[i])
)
)
}
dev.off()
par(mfrow = c(3,3))
for(i in 1:ncol(w3)){
try(silent = TRUE,
print(
ts.plot(na.omit(w3[,i]), main = colnames(w3)[i])
)
)
}
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp)# %>% select(data_series)
dev.off()
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
zoo::rollmean(w3$data_series, 3) %>% ts.plot
zoo::rollmean(w3$data_series, 5) %>% ts.plot
zoo::rollmean(w3$data_series, 15) %>% ts.plot
zoo::rollmean(w3$data_series, 1500) %>% ts.plot
zoo::rollmean(w3$data_series, 150) %>% ts.plot
zoo::rollmean(w3$data_series, 15) %>% ts.plot
zoo::rollmean(w3$data_series, 2000) %>% ts.plot
zoo::rollmean(w3$data_series, nrow(w3)/1000) %>% ts.plot
zoo::rollmean(w3$data_series, nrow(w3)/100) %>% ts.plot
nrow(w3)/100
zoo::rollmean(w3$data_series, nrow(w3)/10) %>% ts.plot
zoo::rollmean(w3$data_series, nrow(w3)/10) %>% plot
zoo::rollmean(w3$data_series, nrow(w3)/10)
zoo::rollmean(w3$data_series, nrow(w3)/100)
zoo::rollmean(w3$data_series, nrow(w3)/10000)
zoo::rollmean(w3$data_series, nrow(w3)/10000) %>% plot
zoo::rollmean(w3$data_series, nrow(w3)/10)
zoo::rollmean(w3$data_series, nrow(w3)/10) %>% plot
zoo::rollmean(w3$data_series, nrow(w3)/2) %>% ts.plot
zoo::rollmean(w3$data_series, 2000) %>% ts.plot
w3 <- zoo::rollmean(w3$data_series, 2000) %>% ts.plot
w3
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- zoo::rollmean(w3$data_series, 2000)
w3
class(w3)
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 %>%
mutate(data_series = zoo::rollmean(data_series, 2000))
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- tibble(zoo::rollmean(w3$data_series, 2000))
w3
glimpse(w3)
example1
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2000),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 2000))
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2000),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 2000))
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2000),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 4))
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2000),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 5))
# database <- fragmentation(distances_calculator(example1))
w3 <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2000),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 2000))
w3 <- tibble(data_series = zoo::rollmean(w3$data_series, 2001),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(w3$data_series, 2001))
GGally::ggpairs(w3)
# database <- fragmentation(distances_calculator(example1))
dff <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, 2001),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmax(dff$data_series, 2001))
ts.plot(w3)
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, 2001),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(dff$data_series, 2001))
ts.plot(w3)
zoo::rollapply(dff$data_series, k = 2001, FUN = sd)
zoo::rollapply(dff$data_series, k = 2001, FUN = var)
zoo::rollapply(dff$data_series, k = 2001, FUN = mean)
rollapply(1:5, width = 3, FUN = sd, na.pad = TRUE)
zoo::rollapply(1:5, width = 3, FUN = sd, na.pad = TRUE)
zoo::rollapply(1:5, width = 3, FUN = sd)
zoo::rollapply(dff$data_series, width = 2001, FUN = mean)
zoo::rollapply(dff$data_series, width = 2001, FUN = sd)
janela <- 1001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(dff$data_series, janela))
ts.plot(w3)
janela <- 3001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
#reference_upper_bound,
#reference_lower_bound,
reference_values = zoo::rollmedian(dff$data_series, janela))
ts.plot(w3)
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference + sd1,
reference_lower_bound = reference - sd1
)
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference + sd1*2,
reference_lower_bound = reference - sd1*2
)
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1*2,
reference_lower_bound = reference_values - sd1*2
)
ts.plot(w3)
ts.plot(w3 %>% select(-sd1))
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1,
reference_lower_bound = reference_values - sd1
)
ts.plot(w3 %>% select(-sd1))
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
ts.plot(w3 %>% select(-sd1))
janela <- 4001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
ts.plot(w3 %>% select(-sd1))
janela <- 10001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
ts.plot(w3 %>% select(-sd1))
janela <- 8001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
ts.plot(w3 %>% select(-sd1))
janela <- 6001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
ts.plot(w3 %>% select(-sd1))
ts.plot(w3 %>% select(-sd1), col = c('black', 'red', 'black', 'black'),
lty = c(1, 2, 2, 2))
tibble(x = 1:10)
tibble(x = 1:10) %>% sample_n(5)
nrow(data)>10000
data = database
data = w3
nrow(data)>10000
tibble(x = 1:nrow(data),
data)
tibble(x = 1:nrow(data),
data) %>% sample_n(10000)
tibble(x = 1:nrow(data),
data) %>% sample_n(10000) %>%
arrange(x)
tibble(x = 1:nrow(data),
data) %>% sample_n(10000) %>%
arrange(x)
graph <- 'none'
source('scripts/IntervalMainPlot.R')
# Chunk 1: setup
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
knitr.svg.object = TRUE,
out.width='50%',
fig.align = 'center'
)
options(digits = 2)
set.seed(13796163)
# Chunk 2
set.seed(13796163)
library(tidyverse)
library(DiagrammeR)
library(knitr)
library(kableExtra)
library(coda)
# library(janitor)
# library(seastests)
# library(DiagrammeR)
# library(prettydoc)
# library(aTSA)
alpha_global <- .05
results <- list()
theme_set(theme_classic())
if(!exists('DocumentType')){
DocumentType <- 2
}
# Chunk 3: cronograma
source('Misc/diagrama.R')
diagram
# Chunk 4
source('https://raw.githubusercontent.com/hbrpaulo/Misc/refs/heads/main/format_sig.R')
format_sig1 <- format_sig
format_sig <- Vectorize(format_sig)
source('Misc/example_creation.R')
source('scripts/distances_calculator.R')
source('scripts/fragmentation.R')
# database <- fragmentation(distances_calculator(example1))
dff <- arrow::read_parquet('https://github.com/petrobras/3W/raw/refs/heads/main/dataset/0/WELL-00001_20170201010207.parquet') %>%
janitor::clean_names() %>%
rename('data_series' = t_jus_ckp) %>% select(data_series)
# Chunk 5
janela <- 6001
w3 <- tibble(data_series = zoo::rollmean(dff$data_series, janela),
reference_values = zoo::rollmedian(dff$data_series, janela),
sd1 = zoo::rollapply(dff$data_series, width = janela, FUN = sd),
reference_upper_bound = reference_values + sd1/2,
reference_lower_bound = reference_values - sd1/2
)
# Chunk 6
database <- fragmentation(distances_calculator(w3))
# Chunk 7: tests_functions
source('scripts/tests/trends_test.R')
source('scripts/tests/seasonalities_test.R')
source('scripts/tests/fragments_comparison_test.R')
source('scripts/interpretations/trends_interpretations.R')
source('scripts/interpretations/seasonalities_interpretations.R')
source('scripts/interpretations/fragments_comparison_interpretations.R')
graph <- 'none'
source('scripts/IntervalMainPlot.R')
results$noref$metrics$trends <- trend_test(database, column = 'data_series')
# Plot the trend decomposition using STL (Seasonal-Trend decomposition using Loess)
plot(
stl(ts(database$data_series, frequency = 10), s.window = 'periodic')[["time.series"]][, 2],
main = str_wrap('Trend Decomposition', width = 35),  # Title for the plot
xlab = 'Observations',  # X-axis label
ylab = 'Trend'  # Y-axis label
)
trends_interpretations(results$noref$metrics$trends)
graph <- 'none'
source('scripts/IntervalMainPlot.R')
results$noref$metrics$trends <- trend_test(database, column = 'data_series')
# Plot the trend decomposition using STL (Seasonal-Trend decomposition using Loess)
plot(
stl(ts(database$data_series, frequency = 10), s.window = 'periodic')[["time.series"]][, 2],
main = str_wrap('Trend Decomposition', width = 35),  # Title for the plot
xlab = 'Observations',  # X-axis label
ylab = 'Trend'  # Y-axis label
)
trends_interpretations(results$noref$metrics$trends)
results$noref$metrics$seasonalities <- seasonality_tests(database, column = 'data_series')
seasonalities_interpretations(results$noref$metrics$seasonalities)
# Create a cyclical series database if it doesn't exist
if (!exists("database")) {
# Parameters for the series
n <- 20  # Number of observations per cycle
m <- 30  # Number of cycles
# Initialize the database
example2 <- tibble(data_series = numeric(n * m))
# Generate the seasonal data series
example2$data_series <-
sapply(
1:m,
FUN = function(x) {
seasonality <- (1:n) / 2  # Create a seasonal pattern
runif(n, 0, n / 5) + seasonality  # Add random noise to the seasonal pattern
}
) %>% as.vector()
database <- fragmentation(example2)
}
# Function to find the variance between cycles for a given frequency
variance_between_cycles <- function(x, freq) {
x <- as.vector(x)
aux <-
try(matrix(x, ncol = freq, byrow = TRUE), silent = TRUE)  # Reshape data into cycles
vars <-
apply(aux, 2, var)  # Calculate variance for each cycle's iteration
return(mean(vars))  # Return the average variance across cycles
}
seasonality_finder <- function(data = database,
n_min = 7, n_centers = 2){
# n_min: Minimum number of elements in each cycle to consider
if(nrow(data)>500){
data <- tibble(nrow_gr_10000 = 1:nrow(data),
data) %>% sample_n(500) %>%
arrange(nrow_gr_10000) %>%
select(-nrow_gr_10000)
}
# Create a data frame to store frequencies and their corresponding variances
aux <- tibble(
freq = n_min:(length(data$data_series) / 3),
# Frequency range
vars = sapply(
n_min:(length(data$data_series) / 3),
FUN = function(f) {
# Calculate variance for each frequency
variance_between_cycles(data$data_series, freq = f)
}
)
)
# Apply k-means clustering to group frequencies based on variance
divide_groups <- kmeans(aux$vars, centers = n_centers)
aux$group <- divide_groups$cluster
return(aux)
}
seasonality_tests <- function(database, column, alpha = alpha_global){
aux <- list()
season_possibilities_all <- seasonality_finder()
# Identify the group with the lowest variance
season_possibilities <- season_possibilities_all %>%
arrange(vars) %>%
slice(1:5) %>%  # Select the five lowest variances
select(-group) %>%
mutate(test = "KW-R",# Specify the test used
pvalue = NA)
j <- 1
for (i in season_possibilities$freq) {
season_possibilities$pvalue[j] <-
seastests::combined_test(ts(database$data_series,
frequency = i), freq = i)$Pval["KW-R p-value"]
j <- j + 1
}
# Find combinations of frequencies that are multiples of one another
season_combinations <- t(combn(season_possibilities$freq, 2))
colnames(season_combinations)[1:2] <- c("freq1", "freq2")
season_combinations <- data.frame(
season_combinations,
has_equivalence = apply(
FUN = function(x) {
ratio <- x[1] / x[2]
return(ceiling(ratio) == floor(ratio))  # Check if freq1 is a multiple of freq2
},
MARGIN = 1,
X = season_combinations
)
) %>%
filter(has_equivalence == TRUE) %>%
janitor::clean_names()  # Clean column names
# Add equivalence results to the season_possibilities data frame
season_possibilities$has_equivalence <-
season_possibilities$freq %in% c(season_combinations$freq1, season_combinations$freq2)
season_possibilities <- season_possibilities %>% arrange(freq)
season_possibilities <- season_possibilities %>%
# add_row(freq = 7, vars = 2, test = 'w', pvalue = .05, has_equivalence = FALSE) %>%
# add_row(freq = 13, vars = 2, test = 'w', pvalue = .1, has_equivalence = FALSE) %>%
# add_row(freq = 17, vars = 2, test = 'w', pvalue = 1, has_equivalence = FALSE) %>%
mutate(significance = case_when(pvalue <= alpha/2  ~ "Alta significância",
pvalue <= alpha ~ "Significância",
pvalue <= alpha*2 ~ "Alguma significância",
.default = 'Não significância'))
aux$season_possibilities <- season_possibilities
aux$season_combinations <- season_combinations
aux$season_possibilities_all <- season_possibilities_all
return(aux)
}
results$noref$metrics$seasonalities <- seasonality_tests(database, column = 'data_series')
graph <- 'none'
source('scripts/IntervalMainPlot.R')
results$noref$metrics$trends <- trend_test(database, column = 'data_series')
# Plot the trend decomposition using STL (Seasonal-Trend decomposition using Loess)
plot(
stl(ts(database$data_series, frequency = 10), s.window = 'periodic')[["time.series"]][, 2],
main = str_wrap('Trend Decomposition', width = 35),  # Title for the plot
xlab = 'Observations',  # X-axis label
ylab = 'Trend'  # Y-axis label
)
trends_interpretations(results$noref$metrics$trends)
results$noref$metrics$seasonalities <- seasonality_tests(database, column = 'data_series')
seasonalities_interpretations(results$noref$metrics$seasonalities)
results$noref$metrics$frag_comparison <- frag_comparison(database, column = 'data_series')
1:10
1:10[1:11]
database$data_series
ks.test(
database$data_series[database$part == x], 'pnorm'
)
ks.test(
database$data_series, 'pnorm'
)
distinct(1:100)
format_sig(1/10^1:4)
1/10^1:4
format_sig(1/10^(1:4))
format_sig <- function(x, k = 3, thresholds = c(0.001, 0.05, 0.1), stars = c("***", "**", "*", "")) {
#' Checks if the value is negative and displays a message
if(x<0)message('Negative values should not be used in this function')
#' Rounds the value to the specified number of decimal places
#' and prevents it from displaying in scientific notation
x <- format(round(x, digits = k), scientific = FALSE)
#' Checks each threshold in sequence and adds asterisks if 'x' is less than or
#' equal to the threshold
star <- stars[findInterval(x, thresholds, left.open = TRUE)+1]
return(paste0(x, star))
}
format_sig(1/10^(1:4))
format_sig <- function(x, k = 3, thresholds = c(0.001, 0.05, 0.1), stars = c("***", "**", "*")) {
#' Checks if the value is negative and displays a message
if(x<0)message('Negative values should not be used in this function')
#' Rounds the value to the specified number of decimal places
#' and prevents it from displaying in scientific notation
x <- format(round(x, digits = k), scientific = FALSE)
#' Checks each threshold in sequence and adds asterisks if 'x' is less than or
#' equal to the threshold
star <- stars[findInterval(x, thresholds, left.open = TRUE)+1]
return(paste0(x, star))
}
format_sig(1/10^(1:4))
1/10^(1:4)
format_sig(1/10^(1:4))
format_sig <- function(x, k = 3, thresholds = c(0.001, 0.05, 0.1), stars = c("***", "**", "*")) {
#' Checks if the value is negative and displays a message
if(x<0)message('Negative values should not be used in this function')
#' Rounds the value to the specified number of decimal places
#' and prevents it from displaying in scientific notation
x <- format(round(x, digits = k), scientific = FALSE)
#' Checks each threshold in sequence and adds asterisks if 'x' is less than or
#' equal to the threshold
star <- stars[findInterval(x, thresholds, left.open = TRUE)+1]
return(paste0(x, star))
}
format_sig(1/10^(1:4))
format_sig(1/10^1:4)
Vectorize(format_sig)(1/10^1:4)
format_sig <- function(x, k = 3, thresholds = c(0.001, 0.05, 0.1), stars = c("***", "**", "*", "")) {
#' Checks if the value is negative and displays a message
if(x<0)message('Negative values should not be used in this function')
#' Rounds the value to the specified number of decimal places
#' and prevents it from displaying in scientific notation
x <- format(round(x, digits = k), scientific = FALSE)
#' Checks each threshold in sequence and adds asterisks if 'x' is less than or
#' equal to the threshold
star <- stars[findInterval(x, thresholds, left.open = TRUE)+1]
return(paste0(x, star))
}
Vectorize(format_sig)(1/10^1:4)
Vectorize(format_sig)(2)
Vectorize(format_sig)(1/10^(1:4))
Vectorize(format_sig)(1/10^(0:3))
